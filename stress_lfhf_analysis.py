# -*- coding: utf-8 -*-
"""Stress_LFHF_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hnK6lrUpqgRAs_y7nq6z0vz_BShl8bZO
"""

# Fitbitで取得した心拍数データから LFHFを推測する．ストレス値について二つの異なる区間の値を比較する
# TEL実験（2022年12月）結果分析用メイン

import json
from datetime import datetime, timedelta

# JSONファイルの読み込み
# ここのファイル名を変える
with open('籠谷_2_heart_rate-2024-10-22.json', 'r') as file:
    data = json.load(file)

for record in data:
    utc_time = datetime.strptime(record["dateTime"], "%m/%d/%y %H:%M:%S")  # UTC時間を日時オブジェクトに変換
    jst_time = utc_time + timedelta(hours=9)  # 9時間追加してJSTに変換
    record["dateTime"] = jst_time.strftime("%m/%d/%y %H:%M:%S")  # JSTの時間にフォーマットを変更

# 変換したデータを新しいJSONファイルに保存
with open('fitbit_data_jst.json', 'w') as file:
    json.dump(data, file, indent=4)

print("UTCからJSTに変換し、保存しました。")

import math
import json
import matplotlib.pyplot as plt
import datetime
import numpy as np
import pandas as pd
from scipy import interpolate
from statistics import mean, stdev ,median
from scipy import stats




# 元のファイルパス
input_filepath = "fitbit_data_jst.json"

# 元のデータを読み込む
with open(input_filepath, 'r') as input_file:
    json_data = json.load(input_file)

# 変換したデータを出力するファイルパス
output_filepath = "new_heart_rate_data.json"

# 新しい形式のデータ
new_data = {
    "activities-heart-intraday": {
        "dataset": []
    }
}

# 元のデータから新しい形式に変換する
for entry in json_data:
    time = entry["dateTime"].split()[1]  # 時刻部分のみ取得する
    bpm_value = entry["value"]["bpm"]
    new_entry = {
        "time": time,
        "value": bpm_value
    }
    new_data["activities-heart-intraday"]["dataset"].append(new_entry)

# JSON形式でファイルに書き込む
with open(output_filepath, 'w') as output_file:
    json.dump(new_data, output_file, indent=2)

print(f"新しい形式のデータを {output_filepath} に保存しました。")



#env
filepath="new_heart_rate_data.json"




#味、色ごとに分けて実験を行った時間を入力
# 4種類の値を入れれるが、必要に応じてコメントアウトして
# 甘味、塩味だけのデータなら、酸味、苦味をコメントアウト
# コメントアウトは範囲選択して、command+/

name = '籠谷'
# ＃10/8
# ＃籠谷Fitbit1
# 甘味
# sweet_clear_start="10:41:00:sweet_clear"
# sweet_red_start="10:50:00:sweet_red"
# sweet_green_start="11:06:00:sweet_green"
# sweet_blue_start="10:45:00:sweet_blue"
# sweet_pink_start="10:54:00:sweet_pink"
# sweet_yellow_start="10:58:00:sweet_yellow"
# sweet_orange_start="11:02:00:sweet_orange"

# # 塩味
# salty_clear_start="11:15:00:salty_clear"
# salty_red_start="11:36:00:salty_red"
# salty_green_start="11:28:00:salty_green"
# salty_blue_start="11:24:00:salty_blue"
# salty_pink_start="11:19:00:salty_pink"
# salty_yellow_start="11:40:00:salty_yellow"
# salty_orange_start="11:32:00:salty_orange"

# # 10/22
# # 籠谷Fitbit1
# # 酸味
acid_clear_start="13:38:00:acid_clear"
acid_red_start="14:06:00:acid_red"
acid_green_start="14:01:00:acid_green"
acid_blue_start="13:43:00:acid_blue"
acid_pink_start="13:50:00:acid_pink"
acid_yellow_start="14:10:00:acid_yellow"
acid_orange_start="13:56:00:acid_orange"

#苦味
bitter_clear_start="14:22:00:bitter_clear"
bitter_red_start="14:26:00:bitter_red"
bitter_green_start="14:30:00:bitter_green"
bitter_blue_start="14:39:00:bitter_blue"
bitter_pink_start="14:47:00:bitter_pink"
bitter_yellow_start="14:34:00:bitter_yellow"
bitter_orange_start="14:43:00:bitter_orange"















#上記を配列に格納
target = [
    # sweet_clear_start,
    # sweet_red_start,
    # sweet_green_start,
    # sweet_blue_start,
    # sweet_pink_start,
    # sweet_yellow_start,
    # sweet_orange_start,

    # salty_clear_start,
    # salty_red_start,
    # salty_green_start,
    # salty_blue_start,
    # salty_pink_start,
    # salty_yellow_start,
    # salty_orange_start,

    acid_clear_start,
    acid_red_start,
    acid_green_start,
    acid_blue_start,
    acid_pink_start,
    acid_yellow_start,
    acid_orange_start,

    bitter_clear_start,
    bitter_red_start,
    bitter_green_start,
    bitter_blue_start,
    bitter_pink_start,
    bitter_yellow_start,
    bitter_orange_start,
]


# 結果を格納するリスト
results = []

# 開始時刻と終了時刻を指定してデータを切り出す
# st, et 開始時刻, 終了時刻
# rri 切り出したデータの出力先（空のリストを渡す）
#　　　RRIデータ 直近1分間の心拍数の逆数 x 1000（ミリ秒換算）
# sec 切り出したデータの時刻出力先．切り出したデータの先頭を０とする．（空のリストを渡す）
def split_data(st,et,rri,sec):
    t=[] #各データの時刻

    for v in json_load['activities-heart-intraday']['dataset']:
        date_dt = datetime.strptime(v['time'],'%H:%M:%S')
        if st <= date_dt and date_dt <et:
            rri.append(60*1000/v['value']) #RRIの計算，v['value']は心拍数
            t.append(date_dt)

    t0=t[0] # 開始時の時刻
    for tn in t:
        td=tn-t0 # データの開始時からの差
        sec.append(td.total_seconds())  #秒数に変換して保存


# リサンプリングする
# interval : インターバル秒ごとにリサンプリング
# length : データ全体の秒数（最初のデータから最後のデータまでの経過秒数）
def resample_rri(rri, sec, interval):
    f = interpolate.interp1d(sec,rri,kind='linear') # 補完関数 for リサンプリング
    num = math.ceil(sec[-1]/interval) #リサンプリング後のデータ数（最後のデータの経過時間をインターバルで割る）
    re_sec = np.linspace(0,sec[-1],num) #リサンプリング後のデータ位置（０番目からの経過秒数）
    re_rri = f(re_sec) #リサンプリング後のデータ
#    print(re_sec)
    sec.clear() # Listデータを削除
    rri.clear() # Listデータを削除
    #リサンプリング後のデータを追加
    for i in range(len(re_sec)):
        sec.append(re_sec[i])
        rri.append(re_rri[i])

# FFTで周波数成分を抽出する
# rri, sec 入力データ（書き換えない）
# lfhf LF/HF比の出力先（空のリストを渡す）
# stress ストレス値の出力先（空のリストを渡す）
# t_lfhf lfhf, stressの時刻出力先（空のリストを渡す）
# interval サンプリング間隔（何秒ごとのデータか）
# width 直近width個のデータを用いてLF/HF成分を抽出する
def do_fft(rri,sec,lfhf,stress,t_lfhf,interval,width):
    N = width # サンプル数
    dt = interval # サンプリング間隔 （何秒ごとのデータか）
    for i in range(N,len(sec)):
        tsec=sec[i-N:i-1] #直近 width分のデータの時刻範囲
        trri=rri[i-N:i-1] #直近 width分のデータ
        F=np.fft.fft(trri) # 高速フーリエ変換
        freq = np.fft.fftfreq(N,d=dt)
        F=F/(N/2) #FFTの結果の正規化
        Amp=np.abs(F) #振幅スペクトルの計算

        lf=0; # LF成分
        hf=0; # HF成分
        for j in range(0,len(tsec)):
            if 0.05<=freq[j] and freq[j]<0.15: #LF成分の取り出し
                lf+=Amp[j]
            elif 0.15<=freq[j] and freq[j]<0.40: #HF成分の取り出し
                hf+=Amp[j]
        if hf != 0: #0割対策
            lfhf.append(lf/hf)
        else:
            lfhf.append(0)
         # ストレス度の計算
        if lf/hf > hf:
            stress.append(lf/hf - hf)
        else:
            stress.append(0)
        t_lfhf.append(tsec[0]) #直近width分データのデータの最初のデータの位置の時刻


json_open = open(filepath, 'r') #データの読み込み
json_load = json.load(json_open)
#print(json_load['activities-heart-intraday']['dataset'])
#for v in json_load['activities-heart-intraday']['dataset']:
#    print(v)

# 切り出し開始時間
# 日付データを与えていないので 1900年1月1日になっている
# st = datetime.datetime(1900, 1, 1, 16, 10, 0)


from datetime import datetime, timedelta
#配列を用いてループ処理を行い、それぞれの実験結果のグラフを出力
for i in range(0, len(target), 1):
    target_start=target[i]
    start_time = datetime.strptime(':'.join(target_start.split(':')[:3]), "%H:%M:%S")  # target_startをdatetimeに変換
    target_end_datetime = start_time + timedelta(minutes=2)  # 2分追加
    target_end = target_end_datetime.strftime("%H:%M:%S")  # datetimeを文字列に変換
    print("target_start:", target_start)
    print("target_end:", target_end)




    st=target_start.split(':')
    et=target_end.split(':')
    condition_name = st[3]
    print(condition_name)

# その後のコード
    st_t = datetime(1900, 1, 1, int(st[0]), int(st[1]), int(st[2]))
    et_t = datetime(1900, 1, 1, int(et[0]), int(et[1]), int(et[2]))



    rri_t=[] #RRIデータ 直近1分間の心拍数の逆数 x 1000（ミリ秒換算）
    sec_t=[] # 最初のデータからの経過秒数



    split_data(st_t,et_t,rri_t,sec_t)



    # リサンプリング前RRIグラフの描画
    #
    plt.ylabel('RRI '+st[3])
    plt.xlabel('Time')
    plt.plot(sec_t,rri_t)
    plt.show()



    interval=1
    #リサンプリング（rri, secの中身が書き変わる）
    resample_rri(rri_t, sec_t, interval)



    # RRIグラフの描画
    plt.ylabel('Re-RRI '+st[3])
    plt.xlabel('Re-Time')
    plt.plot(sec_t,rri_t)
    plt.show()



    # フーリエ変換
    # width = 60*1 # 直近width個のデータを用いてLF/HF成分を抽出する
    # 窓
    width = 50


    lfhf_t=[]; #LFHF比データを入れるリスト
    t_lfhf_t=[]; #LFHF比のデータの時刻
    stress_t=[]; #ストレス度 IPSJ-Z77-2U-07.pdf参照


    do_fft(rri_t,sec_t,lfhf_t,stress_t,t_lfhf_t,interval,width)



    #lf/hfグラフの描画
    #
    plt.ylabel('LF/HF '+st[3])
    plt.xlabel('Time')
    for i in range(len(t_lfhf_t)):
        plt.plot(t_lfhf_t[i:i+2], lfhf_t[i:i+2], color= 'red' if lfhf_t[i] >= 1.5 else 'blue')
   # LF/HF比の縦軸範囲を設定
    plt.ylim(0, 7)
    plt.savefig("LFHF_"+st[3]+"_"+name+".pdf") #グラフデータの保存
    plt.show()

    lfhf_mean = mean(lfhf_t) if lfhf_t else 0
    lfhf_sd = stdev(lfhf_t) if len(lfhf_t) > 1 else 0
     # 最小値、中央値、最大値を計算
    lfhf_min = min(lfhf_t) if lfhf_t else 0
    lfhf_median = median(lfhf_t) if lfhf_t else 0
    lfhf_max = max(lfhf_t) if lfhf_t else 0

    # 閾値を超えた割合を計算
    lfhf_threshold_ratio = sum(1 for x in lfhf_t if x >= 1.5) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio1 = sum(1 for x in lfhf_t if x >= 1.8) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio2 = sum(1 for x in lfhf_t if x >= 2) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio3 = sum(1 for x in lfhf_t if x >= 2.3) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio4 = sum(1 for x in lfhf_t if x >= 2.5) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio5 = sum(1 for x in lfhf_t if x >= 2.8) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio6 = sum(1 for x in lfhf_t if x >= 3) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio7 = sum(1 for x in lfhf_t if x >= 3.5) / len(lfhf_t) * 100 if lfhf_t else 0
    lfhf_threshold_ratio8 = sum(1 for x in lfhf_t if x >= 4) / len(lfhf_t) * 100 if lfhf_t else 0
    #LFHFが1.5を超えた時間を計測する
    b_lfhf_ob = 0
    y_lfhf_ob = 0
    for i in range(len(t_lfhf_t)):
        if lfhf_t[i] >= 1.5:
            b_lfhf_ob+=interval
    #print("LFHF>=1.5(blue)[sec]:"+str(b_lfhf_ob)+", average:"+str(b_lfhf_ob/len(t_lfhf_b)))


    #ストレス度の描画
    #
    plt.ylabel('Stress '+st[3])
    plt.xlabel('Time')
    for i in range(len(t_lfhf_t)):
        plt.plot(t_lfhf_t[i:i+2], stress_t[i:i+2], color= 'red' if stress_t[i] >= 0.5 else 'blue')
    # 縦軸の設定
    plt.ylim(0, 5)
    plt.savefig("Stress_"+st[3]+"_"+name+".pdf") #グラフデータの保存
    plt.show()

    stress_mean = mean(stress_t) if stress_t else 0
    stress_sd = stdev(stress_t) if len(stress_t) > 1 else 0
    stress_threshold_ratio = sum(1 for x in stress_t if x >= 0.5) / len(stress_t) * 100 if stress_t else 0
    stress_min = min(stress_t) if stress_t else 0
    stress_median = median(stress_t) if stress_t else 0
    stress_max = max(stress_t) if stress_t else 0


    #Stressが0.5を超えた時間を計測する
    b_stress_ob = 0
    for i in range(len(t_lfhf_t)):
        if stress_t[i] >= 0.5:
            b_stress_ob+=interval



    print("LFHF>=1.5("+st[3]+")[sec]:"+str(b_lfhf_ob)+", average:"+str(b_lfhf_ob/len(t_lfhf_t)))
    print("Stress>=0.5("+st[3]+")[sec]:"+str(b_stress_ob)+", average:"+str(b_stress_ob/len(t_lfhf_t)))
    print("Stress ("+st[3]+") average:"+str(mean(stress_t)))

    # 小数点以下2桁に揃える
    lfhf_mean = f"{lfhf_mean:.5f}"
    lfhf_sd = f"{lfhf_sd:.5f}"
    stress_mean = f"{stress_mean:.5f}"
    stress_sd = f"{stress_sd:.5f}"
    # 最小値、中央値、最大値を2桁に揃える
    lfhf_min = f"{lfhf_min:.5f}"
    lfhf_median = f"{lfhf_median:.5f}"
    lfhf_max = f"{lfhf_max:.5f}"

    stress_min = f"{stress_min:.5f}"
    stress_median = f"{stress_median:.5f}"
    stress_max = f"{stress_max:.5f}"
    lfhf_threshold_ratio = f"{lfhf_threshold_ratio:.2f}"
    lfhf_threshold_ratio1 = f"{lfhf_threshold_ratio1:.2f}"
    lfhf_threshold_ratio2 = f"{lfhf_threshold_ratio2:.2f}"
    lfhf_threshold_ratio3 = f"{lfhf_threshold_ratio3:.2f}"
    lfhf_threshold_ratio4 = f"{lfhf_threshold_ratio4:.2f}"
    lfhf_threshold_ratio5 = f"{lfhf_threshold_ratio5:.2f}"
    lfhf_threshold_ratio6 = f"{lfhf_threshold_ratio6:.2f}"
    lfhf_threshold_ratio7 = f"{lfhf_threshold_ratio7:.2f}"
    lfhf_threshold_ratio8 = f"{lfhf_threshold_ratio8:.2f}"

    stress_threshold_ratio = f"{stress_threshold_ratio:.2f}"

    # 条件ごとの結果を追加
    results.append({
        "Condition": condition_name,
        "LF/HF_Mean": lfhf_mean,
        "LF/HF_SD": lfhf_sd,
        "LF/HF_Min": lfhf_min,
        "LF/HF_Median": lfhf_median,
        "LF/HF_Max": lfhf_max,
        "LF/HF > 1.5 (%)": lfhf_threshold_ratio,
        "LF/HF > 1.8 (%)": lfhf_threshold_ratio1,
        "LF/HF > 2.0 (%)": lfhf_threshold_ratio2,
        "LF/HF > 2.3 (%)": lfhf_threshold_ratio3,
        "LF/HF > 2.5 (%)": lfhf_threshold_ratio4,
        "LF/HF > 2.8 (%)": lfhf_threshold_ratio5,
        "LF/HF > 3.0 (%)": lfhf_threshold_ratio6,
        "LF/HF > 3.5 (%)": lfhf_threshold_ratio7,
        "LF/HF > 4.0 (%)": lfhf_threshold_ratio8,
        "Stress_Mean": stress_mean,
        "Stress_SD": stress_sd,
        "Stress_Min": stress_min,
        "Stress_Median": stress_median,
        "Stress_Max": stress_max,
        "Stress > 0.5 (%)": stress_threshold_ratio,
    })

# 結果をデータフレーム形式に変換
df_results = pd.DataFrame(results)

# コンソールに表示
print(df_results)

# CSVファイルに保存
output_csv = "experiment_analysis_results_with_min_median_max.csv"
df_results.to_csv(output_csv, index=False)
print(f"結果を {output_csv} に保存しました。")


    #print(stress)
    #print(lfhf)